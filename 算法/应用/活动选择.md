# 活动选择

有一个$$n$$个活动的集合$$S=\{a_1, a_2, ...,a_n\}$$，这些活动使用同一个资源。而这个资源在某个时刻只能供一个活动使用。每个活动有一个开始时间$$s_i$$和一个结束时间$$f_i$$，其中$$0\le s_i \lt f_i$$。如果两个活动满足$$[s_i, f_i)$$和$$[s_j, f_j)$$不重叠，则称它们**兼容**。求最大的**兼容活动集**。假设活动按结束时间升序排列。

| i     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| $$s_i$$ | 1    | 3    | 0    | 5    | 3    | 5    | 6    | 8    | 8    | 2    | 12   |
| $$f_i$$ | 4    | 5    | 6    | 7    | 9    | 9    | 10   | 11   | 12   | 14   | 16   |

## 求解方法

1. [贪心算法](../算法与分析技术/贪心算法.md) $$O(n)$$ 

---

### 贪心算法

每次选择$$S$$中最早结束的活动。

**定理**：设$$a_m$$是$$S_k$$中结束最早的活动，则$$a_m$$在$$S_k$$的某个最大兼容活动子集中。

**证明**：设$$A_k$$是$$S_k$$的一个最大兼容活动子集。且$$A_j$$是$$A_k$$中结束时间最早的活动，若$$A_j=A_m$$，则命题成立。若$$A_j\ne A_m$$，令集合$$A^`_k$$为$$A_k$$去掉$$A_j$$加上$$A_m$$，由于$$A_k$$中的活动互不相交，加入比最早结束的$$A_j$$还早的$$A_m$$必然还是不相交，这说明$$A^`_k$$也是$$S_k$$的一个最大兼容活动子集，定理得证。

```go
// GreedyActivitySelector O(n)
// f is sorted
func GreedyActivitySelector(s, f []int) []int{
	n := len(s)
	A := []int{0}
	k := 0
	for m := 1; m < n; m++ {
		if s[m] >= f[k] {
			A = append(A, m)
			k = m
		}
	}
	return A
}
```

