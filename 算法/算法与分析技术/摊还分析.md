# 摊还分析

在**摊还分析**中，我们求数据结构的一个操作序列中所执行的所有操作的平均时间，来评价操作的代价。这样，我们可以说明一个操作的平均时间是很低的。摊还分析不同于平均情况分析，不涉及概率，它可以保证最坏情况下每个操作的平均性能。

[TOC]

<!-- toc -->

## 摊还分析的三种方法

* 聚合分析
* 核算法
* 势能法

## 应用

1. [动态表](../应用/动态表.md)

---

### 例子 栈操作

* $$PUSH(S, x)$$：将$$x$$压入栈$$S$$中 代价为$$1$$。
* $$POP(S)$$: 弹出栈顶元素，空栈不可调用 代价为$$O(1)$$。
* $$MULTIPOP(S, k)$$: 删除栈顶的$$k$$个元素，栈中元素数小于$$k$$则全部弹出 代价为$$min(s, k)$$。

```go
// Stack is stack
type Stack struct {
	A []int
	top int
}

// Init create a stack
func Init() Stack {
	S = Stack{top: -1}
}

func pop(S Stack) {
	if S.top > -1 {
		top--
		return S.A[top+1]
	}
}

func push(S Stack, x int) {
	if S.top < len(S.A) {
		top++
		S.A[top] = x
	}
}

func multipop(S Stack, k int) {
	for S.top != -1 && k > 0 {
		pop(S)
		k--
	}
}
```

---

### 聚合分析

考虑整个序列的n个操作，虽然一个单独的$$MULTIPOP$$操作代价很高，但在一个空栈上执行$$n$$个$$PUSH$$、$$POP$$、$$MULTIPOP$$操作序列，代价至多为$$O(n)$$。因为将一个对象压入栈内，至多将其弹出一次。因此，对于一个非空的栈，可以执行的$$POP$$操作次数至多与$$PUSH$$相当，即最多n次。因此$$n$$个操作序列最多花费$$O(n)$$时间。一个操作的平均时间为$$O(n)/n=O(1)$$。因此三种栈操作的摊还代价为$$O(1)$$。

---

### 核算法

核算法对不同操作赋予不同的费用，费用称为该操作的**摊还代价**。当摊还代价大于实际代价，将差额存入数据结构的特定对象中，差额称为**信用**。对于后续操作中摊还代价小于实际代价的情况中，信用可以支付差额。小心地选择操作的摊还代价，确保操作序列的总摊还代价给出了序列总真实代价的上界。

#### 栈操作的实际代价

| $$PUSH$$     | 1             |
| ------------ | ------------- |
| $$POP$$      | 1             |
| $$MULTIPOP$$ | $$min(k, s)$$ |

#### 摊还代价

| $$PUSH$$     | 2    |
| ------------ | ---- |
| $$POP$$      | 0    |
| $$MULTIPOP$$ | 0    |

下面证明按摊还代价缴费，可以支付任意的栈操作序列的实际代价。

$$PUSH$$操作摊还代价高于实际代价，多余的1代价作为**信用**存到被压入的元素中，作为将来它被弹出栈时的代价。$$POP$$和$$MULTIPOP$$操作摊还代价为0，它们欠的代价都由元素自身的**信用**支付。因此摊还代价是实际代价的上界。由于总摊还代价为$$O(n)$$，因此总实际代价也是。

---

### 势能法

势能法将预付代价表示为**势能**，而不是**信用**。同时，势能与整个数据结构相关，而不是数据结构的特定对象。

工作方式如下，对一个初始数据结构$$D_0$$执行$$n$$个操作，对每个$$i=1,2,...,n$$，令$$c_i$$表示第$$i$$个操作的实际代价，令$$D_i$$表示在数据结构$$D_{i-1}$$上执行第$$i$$个操作得到的数据结构。**势函数**$$\phi$$将每个数据结构$$D_i$$映射到一个实数$$\phi(D_i)$$，称为数据结构$$D_i$$的**势**。

第$$i$$个操作的摊还代价$$\hat c_i$$定义为：
$$
\hat c_i = c_i + \phi(D_i) - \phi(D_{i-1})
$$
因此每个操作的摊还代价等于其实际代价加上此操作引起的势能变化。$$n$$个操作的总摊还代价为
$$
\sum_{i=1}^{n}\hat c_i = \sum_{i=1}^{n}(c_i + \phi(D_i) - \phi(D_{i-1})) = \sum_{i=1}^{n}c_i + \phi(D_n) - \phi(D_0)
$$
因此，如果定义一个势函数，使得$$\phi(D_n)\ge \phi(D_0)$$，则总摊还代价给出了总实际代价的上界。

#### 栈操作的势函数

栈的势函数定义为其中的对象数量。

由于栈中对象数目永远不可能为负，所以$$\phi(D_i)\ge 0 = \phi(D_0)$$。因此总摊还代价是总实际代价的上界。接下来计算具体操作的摊还代价。

$$PUSH$$: $$\hat c_i = c_i + \phi(D_i) - \phi(D_{i-1}) = 1 + 1 = 2$$

$$POP$$: $$\hat c_i = c_i + \phi(D_i) - \phi(D_{i-1}) = 1 - 1 = 0$$

同理$$MULTIPOP$$摊还代价为0，总摊还代价为$$O(n)$$。所以n个操作的最坏情况时间为$$O(n)$$。