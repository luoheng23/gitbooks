# 最大子数组

假设A[1...n]是一个有n个不同数的数组，A的和最大非空连续子数组称为最大子数组。

### 寻找最大子数组的算法

1. [分治法](../算法与分析技术/分治法.md)(O(nlgn))

2. [动态规划](../算法与分析技术/动态规划.md)(O(n))

---

### 分治法

A[low...high]的任何连续子数组A[i...j]所处的位置必然是以下三种情况之一：

* 完全位于子数组A[low..mid]中，因此low<=i<=j<mid
* 完全位于子数组A[mid...high]中，因此mid<=i<=j<high
* 跨越了中点，因此low<=i<=mid<j<high

```go
// O(n)
func maxCrossSubArray(A []int, low, mid, high int) (leftPos int, rightPos int, sum int) {
	left := -int(^uint32(0) >> 1)
	right := left
	leftPos, rightPos = -1, -1
	for i := mid; i > low; i-- {
		sum += A[i]
		if sum > left {
			left, leftPos = sum, i
		}
	}
	sum = 0
	for i := mid + 1; i < high; i++ {
		sum += A[i]
		if sum > right {
			right, rightPos = sum, i
		}
	}
	sum = left + right
	return leftPos, rightPos, sum
}

// MaxSubArray O(nlgn)
func MaxSubArray(A []int, low, high int) (leftPos int, rightPos int, sum int) {
	if high == low+1 {
		return low, high, A[low]
	}
	mid := (low + high) / 2
	leftLeftPos, leftRightPos, leftSum := MaxSubArray(A, low, mid)
	rightLeftPos, rightRightPos, rightSum := MaxSubArray(A, mid, high)
	crossLeftPos, crossRightPos, crossSum := maxCrossSubArray(A, low, mid, high)
	if leftSum >= rightSum && leftSum >= crossSum {
		return leftLeftPos, leftRightPos, leftSum
	} else if rightSum >= leftSum && rightSum >= crossSum {
		return rightLeftPos, rightRightPos, rightSum
	}
	return crossLeftPos, crossRightPos, crossSum
}
```

### 动态规划

对数组A[1...n]，i从1到n，每次查找以A[i]结尾的最大子数组。步骤如下：

1. 若i等于1，则以A[i]结尾的最大子数组为A[1]
2. 若i不等于1，则若A[i-1]的最大子数组和大于0，则A[i]的最大子数组为A[i-1]的最大子数组加上A[i]，若其小于0，则A[i]最大子数组为其自身
3. 最大子数组必以其中一个元素结尾，所以再遍历一遍找到的最大子数组，即可得到答案

```go
// MaxSubArrayLine O(n)
func MaxSubArrayLine(A []int) (leftPos int, rightPos int, sum int) {
	var l, r, s int
	for i, e := range A {
		if s >= 0 {
			s += e
			r++
		} else {
			s = e
			l, r = i, i
		}
		if sum < s {
			leftPos, rightPos, sum = l, r, s
		}
	}
	return leftPos, rightPos, sum
}
```

